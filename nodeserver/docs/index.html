<div style='width: 800px;'><pre style='word-wrap: break-word;overflow-x:auto;white-space:pre-wrap;'>                         <b>The TextTemplate Language</b>

I. <b>Language Structure</b> — The TextTemplate language is composed of relatively few language components.  At its most basic, there is a template that is composed of literal characters and braced tokens.  There are several kinds of tokens, listed below, including some that can invoke other templates, called subtemplates.  Templates are usually executed (interpolated) in a data context where the embedded tokens can refer to data attributes by identifiers, which, when used in a token, will be replaced by the data attribute's value.  Data is often hierarchical, and identifiers can identify hierarchical data using "dot" notation.  For example, a data structure that incorporates an address attribute whose value contains a primary and secondary street name as well as a city and zip code might be identified using {address.city}, {address.state}, etc.  Values represented by identifiers can be modified by methods, which are built-in routines to modify, manipulate, or test the values.  Templates, or rather the results of template interpolation, can also be modified by methods.  Methods can have arguments that can be literal strings (strings enclosed by quotes or apostrophes), templates or identifiers and, those arguments can also be modified by methods, etc. etc.  Interpolation can be conditional based on expressions ("predicates") that are composed of relational operators between two values being compared, where the values can be specified as literals, identifiers or templates.  The following provides additional details:

II. <b>Templates</b> — TextTemplate templates consist of literal strings containing embedded tokens.  Every character in a template is interpreted literally with the exception of bracket, braces and the backtick ("`") character, specific white space and comments (see below).

III. <b>Subtemplates</b> — TextTemplate templates may be divided into two sections with the text "Subtemplates:" acting as the dividing point.  The text above the divider contains the string to be interpolated.  Below the divider, multiple subtemplates can be specified using the format "{#name:[contents]}".  These named subtemplates are the functional equivalents of bracketed subtemplates, so a subtemplate name (including the "#") can replace any bracketed expression in the language syntax, including template tokens, context tokens, and the thin or thick arrow conditional tokens, described below.  Subtemplates provide for modularity, re-use, clarity and readability, where template contents, long conditional expressions, complex method invocations can be replaced by instructively named subtemplates.  Named subtemplates are scoped to the template in which they are specified and are accessible by any nested subtemplates.  Lower level named subtemplates will override high level inherited subtemplates.  In the event that a subtemplate is not found, TextTemplate will attempt to load the subtemplate from the local server using the url '/subtemplate/[subtemplate-name-without-pound-sign]'.

IV. <b>Tokens</b> — Tokens consist of specifications enclosed by braces.  Within the braces, the language has a rich set of functionality for retrieving and operating on data, described below.  Basic tokens contents consist of:
   
   (a) <b>Literal Tokens</b>, e.g. {"this is a token"} and {'so is this'}, which can be used, among other things, to output reserved characters, like braces and brackets.  There are type of literal tokens:
      • <b>Quoted</b> literals (surrounded by quote signs) that support escape sequences identical to those used in JSON quoted string, including escaped Unicode
      • <b>Apostrophed</b> literals (surrounded by apostrophes) that support only the backslash apostrophe and new line escape sequences.  Apostrophed literals can be conveniently used to contain JSON strings
   (b) <b>Template Tokens</b>, e.g.  {[Here is a template in a token]} and {[a template in a token that contains a {'literal token'}]} and {#this}
   (c) <b>Value Tokens</b>, e.g. {lastName} and {address.state} , which consist of an identifier surrounded by braces .  Value tokens are replaced with retrieved data values to create an interpolated string.  Value tokens are used to retrieve scalar data types (see below).  
   (d) <b>Context Tokens</b>, which are the mechanism for specifying how non-scalar data e.g., objects, are to be interpolated.  Context tokens have the syntax {DataSource:[template]}, where DataSource is a complex data type (see below) that can be specified using:
      • a <b>JSON string</b>, as in {'{"data":"value"}':[this is the {data}]}
      • a <b>url</b>, as in {'https://api.github.com/users/eisnerw':[Bill is a Github "{type}"]}
      • a <b>relative url</b>, as in {'/data/simple':[{firstName} {lastName}]}
      • a <b>dictionary or list</b> value from a data source, as in {'/data/nested':[{firstName} owns a {pets:[{type}]}]}
   (e) <b>Conditional Tokens</b> — there are two tokens that can control the flow of execution based on conditions: the thin arrow and the thick arrow:
      • The <b>thin arrow</b>consists of a predicate (a conditional expression) followed by "-&gt;" followed by either a bracketed subtemplate or a named subtemplate. For example, a template with a thin arrow might be something like [{firstName {middleName-&gt;[ {middleName}]} {lastName}].  In this template, the presence of a middle name can be tested by using the variable as a predicate and, if it is present, a subtemplate can format the middle name with a preceding space.
      • The <b>thick arrow</b>, "=&gt;", is fundamentally the same except that it provides two subtemplates, one for the true case and one for the false case.  The thick arrow is very much like the Java/C/C++/C# conditional operator, "?" which is composed of a predicate followed by a delimiter followed by a true expression another delimiter and a false expression.  The structure for the thick arrow token is {condition=&gt;[true],[false]} as in, [He was born in the {dob.ToDate('YYYY') &gt; 1999 =&gt; [twenty first],[twentieth]} century]. 
   (f) <b>Bullet Tokens</b>, special tokens in the form "{.}" that are used to automatically add letters, symbols and numbers to the text to enumerate lists of data

V. <b>Data Types</b> — Value tokens retrieve data that can be any of the data types supported by JSON:
   
   (a) <b>Scaler</b> Types:
      • <b>string</b> — strings, whether produced by literals or retrieved as values from data sources, are the fundamental data type of the TextTemplate language.
      • <b>null</b> — A null is equivalent to a missing value.  
      • <b>boolean</b> — Boolean values can participate in conditional expressions (see below) but are otherwise treated as the strings "true" and "false".  
      • <b>number</b> — The TextTemplate language does not currently support arithmetic operations but it does support relative operators (e.g., greater than and less than).  Numerical values by themselves are treated as strings.  Numerical comparison uses a form of "duck" typing where values, including strings, that can be parsed as a number are treated as such in numerical comparisons if both comperands can be parsed as numbers.  
   (b) <b>Complex</b> Types:
      • <b>dictionary</b> — Dictionaries (sometimes called "maps" or "objects") relate attributes to values as the do in JSON and JavaScript.  In the TextTemplate language, the mapping takes place within a context token where value tokens within the context token's template are retrieved from the context token's data source.
      • <b>list</b> — Lists (sometimes called "arrays") are typically ordered collections of dictionaries. The TextTemplate language also supports lists of scaler data types, such as strings, numbers, etc., by representing them as dictionaries, one per item, with the attribute of underscore ("_") mapping to one scalar value in each dictionary. 

VI. <b>Multiple Occurrence</b> — TextTemplate Lists typically represent multiple occurrences an attribute in a parent dictionary.  Like dictionaries, lists require a context token to specify how the attributes in the listed dictionaries are to be interpolated.  A single dictionary is treated by the language as a degenerate case of a list with one element.  In this way, context tokens, whether lists or dictionaries, can be used  to interpolate data that is anticipated to sometimes have multiple values.  Multiple values are typically interpolated as indented lists (see next).  By invoking a value token on an indented line below the parent data, TextTemplate will always create a list, even if their is a single value.  If the value is invoked on the same line as the parent data, TextTemplate will only create an indented list for multiple values.

VII. <b>Bulleting and indenting</b> — The TextTemplate language processes a list of dictionaries by automatically creating separate indented (and optionally bulleted) lines of text to display values from each of the dictionaries in the list.  Indenting can be explicit, where the template invokes the value template on a separate line, or implicit, where the value template is on the same line as the parent data.  Explicitly indented data follows the template; implicitly indented data uses a default indent value that can be overridden with the @IndentValue annotation (see below)

VIII. <b>Missing Values</b> — TextTemplate deals with missing or null values based on a global setting (@MissingValue) and the IfMissing method (see below).  When one of the mechanisms has been invoked, TextTemplate will substitute a replacement value for the missing value.  When neither mechanism specifies a missing value replacement, the missing value (or null) will cause the contents of the line of text containing the missing value to be eliminated.  This avoids the necessity for testing for a null values although that can be done to override this behavior.

IX. <b>Methods</b> — TextTemplate provides methods that can be applied to data values, subtemplates, literals, and the results of other methods in order to produce a modified value.  For example, the method .ToUpper() can be used to capitalize a data value or the entire interpolated output of a subtemplate.  Methods use the syntax dot followed by method name followed by, optionally, arguments enclosed within parenthesis.  Method names are capitalized using "Pascal" case, in which the first letter of each word of the method name is capitalized.  Method arguments are variable depending upon the specific method.  Many methods take string arguments, which can be literals (text surrounded by either quotes or apostrophes) or subtemplates.  Methods that take numerical arguments can be invoked with string values that can be automatically converted to a number.  A few methods also permit or require regular expressions, which use the JavaScript syntax including modifiers.  
Methods can be roughly categorized as involved in string manipulation, data formatting, list processing, value testing, annotations and debugging:
   
   (a) <b>String Manipulation Methods</b>
      • <b>ToLower</b> — This method takes no arguments.  It converts any upper case characters within a string to lower case
      • <b>ToUpper</b> — This method takes no arguments.  It converts any lower case characters within a string to upper case
      • <b>Trim</b> — This method takes no arguments.  It removes leading white space (spaces, tabs, new lines) from the beginning and end of a string
      • <b>Align</b> — This method takes between one and three arguments.  It expands the size of a string to a specified length by padding the string based on an optional specification of 'L', 'R', or 'C' to the right, left or both with a blank or an optional character or sequence.  By default, the method aligns the string to the left by padding with blanks to the right.  If the string's length is equal or larger than the specified length, the method has no effect.
      • <b>Replace</b> — This method tales two arguments.  The first argument, which may be a string or a regular expression, finds all matching characters to be replaced in the string.  The method replaces the found characters with the string in the second argument.  Note that this replace is different from the JavaScript replace() in that it replaces all instances.  A regular expression can be utilized to replace a single instance. 
      • <b>Case</b> — This method, which takes at least two arguments, replaces strings that totally match odd arguments with replacement string from the adjacent even argument.  In the event that no match is found and the method has an odd number of arguments, the string is replaced by the last argument.  Otherwise, the method has no effect.  Note that in addition to simple strings, the Case method even be subtemplate specifications.  In this way, the Case method can be used to perform different functionality 
      • <b>Substr, IndexOf and LastIndexOf</b> — These methods are designed to mimic the corresponding substr(), indexOf, and lastIndexOf JavaScript functions.  Substr takes one or two arguments and extracts the contents of a string starting at the position of the first argument, which is zero-origined. The optional second argument specifies the maximum number of characters to be extracted. In the absence of a second argument, the method extracts all characters starting from the position of the first argument.
      • <b>IfMissing</b> — This method takes zero or one argument and only functions if the value to which it is being applied is null, an empty string, or missing.   In those cases, if there is an argument, the value of that argument is substituted for the missing value.  If the method has no arguments, the result is a null value.  Note that this method takes precedence over and @MissingValue annotation that may be in effect.
   (b) <b>Formatting methods</b>
      • <b>ToDate</b> — This method takes zero one argument.  The function formats any string that can be interpreted as a date or date and time using a format specification from the method's argument.  The method has been implemented using the MomentJs library's format function and it follows the specifications of that library (see: https://momentjs.com/docs/#/displaying/).  When no argument is specified, the method converts the string to the local date format of the machine where TextTemplate is hosted.  Note that this method provides explicit date formatting that overrides date formatting provided implicitly through the @DateTest() and @DateFormat() annotations, below. 
      • <b>EncodeFor</b> — This method takes a single argument that must be 'html', 'xml' or 'uri'.  The method encodes a string by replacing appropriate characters within the string so they will be accurately represented when rendered html, xml, or uri strings.  Note that the @EncodeDataFor() annotation should be used to encode data.
      • <b>Compose</b> — This method, which takes no arguments and is typically applied to a template, is used to isolate bullet styles and numbering from other bullet styles and numbering in an enclosing template.  Bullet interpolation in TextTemplate is performed following all other interpolation so the relative position of the bullets can be determined, and numbering can be applied across bullets found in multiple subtemplates.  This method performs the final bullet interpolation, creating a string that is no longer subject to interpolation.  In this way, numbering or formatting of a specific subtemplate can be performed without affecting any other bulleting.  
   (c) <b>List Processing Methods</b> — these methods are all applied to lists of dictionaries or, as a degenerate case, a single dictionary.
      • <b>Where</b> — This method takes a single argument, which is a predicate expression.  The method creates a new list (or a single dictionary) composed of all items from the list that meet the conditions of the predicate.  In the even that no items meet the criteria, the method produces a null
      • <b>Count</b> — This method zero or a single argument, which is a predicate expression.  The method produces a number reflecting the number of items in the list that meet the conditions of the predicate.  With no arguments, this method produces the count of the number of items in the list.  
      • <b>OrderBy</b> — This method takes a single argument that specifies an attribute from the dictionaries in the list or any argument that results in a string, presumably calculated from attributes in the list's dictionaries.  The method produces a new list containing the original items, ordered by the specification.  Note that the original order of the list is retained for items that all match the same specification, so this method can be used multiple times to first order by a lower level attribute and then by successively higher level attributes to obtain a list ordered by multiple attributes.  
      • <b>GroupBy</b> — This method, which takes two or three arguments, manipulates a list to creating a new list that can be used as a context with a subtemplate to display the original list grouped by a named field or a calculated value.  The new list will contain a dictionary with two attributes, one specifying the group and the other containing items from original list that fit in that group.  The method's first argument specifies the grouping, which can be the name of an attribute from the dictionaries in the list or any argument that can produce a string, presumably taken values from attributes in the list's dictionaries.  The second argument specifies the name of the attribute in the resulting new list's dictionaries that will contain the list of all of the items from the original list that match that grouping.  The third argument specifies the name of the attribute in the new list's dictionary that holds the group's name.  When grouping is done with a single attribute, that attribute's name will be used to hold the group's name and the third argument can be omitted.
      • <b>Join</b> — This method takes one or two arguments and is used to create a single string from the string array that results from applying a template to a list.  The first argument specifies the string that is used between each of the items in the array.  If there is a second argument, the string specified in that argument is used between the penultimate and ultimate items in the last. The method has no effect when applied to a single value.  When used with a single argument, the method can create comma- or semicolon-separated lists.  With the second argument, the method can produce a conjunction with "and" "or" or other words between the last two items in the list.  
   (d) <b>Value-Testing Methods</b> — These methods all participate in predicates by testing values for specific conditions.  In addition to these methods, the TextTemplate language supports the following relational operators: =, !=, &lt;, &lt;=, and &gt;=.  The language also supports parenthecized expressions, the logical operators &amp; (and) and | (or) as well as the "not" operator, !, that can be placed prior to any parentical expression or value testing specification, as in !abc.Contains('x') | !(def.EndsWith('q') &amp; xyz.StartsWith('y')).  Each of the relational and logical operators evalutes as a boolean value.  A data variable when used in the context of a logical operator, as the "def" in abc.Contains('x') &amp; def evaluates as false if the value is  missing, null or an empty string and otherwise true.  The following functions also evalute to boolean values:
      • <b>Contains</b> — This method, which performs the same function on strings as JavaScript .includes(), takes a single string argument that can be used to determine if a string contains the text specified in the argument.
      • <b>StartsWith</b> — This method, which performs the same function on strings as JavaScript .startsWith(), takes a single string argument that can be used to determine if the beginning of a string equals the text specified in the argument.
      • <b>EndsWith</b> — This method, which performs the same function on strings as  JavaScript .endsWith(), takes a single string argument that can be used to determine if ending of a string equals the text specified in the argument.
      • <b>Matches</b> — This method takes one or more arguments and return true if any of the arguments matches the value to which it is being applied.  Arguments can be either string values or regular expressions and "matches" for string value means that the text of the value and the argument are equal.  For regular expressions, a match is achieved whenever a regular expression test() would produce true. 
   (e) <b>Annotation Methods</b> — These methods, known as "annotations", are always applied to templates (or subtemplates) and are designed to bias the processing of those templates and any nested subtemplates encountered during the interpolation of the templates.  Annotations are inherited by subtemplates and can be overridden by annotations on the subtemplate.  Annotations on a template are evaluated prior to the interpolation of that template.  Annotations can be mixed with other methods being performed on a template in any order because annotations are evaluated prior to template interpolation and other methods are applied after the template has been interpolated.
      • <b>@MissingValue</b> — this annotation, which takes zero or one argument, specifies the string value that will be substituted for any missing, null or empty string value that is encountered when retrieving data from a TextTemplate context.  When specified without an argument, missing values remain missing or null.  Note that @MissingValue can be explicitly overridden by the use of the IfMissing method
      • <b>@DateTest</b> — this annotation takes a single regular expression argument.  The annotation is used to detect those attributes encountered during the processing of the template that will contain date values.  It does so by testing each attribute name to see if it matches the regular expression in the argument.  Dates that are detected by the @DateTest mechanism are automatically formatted as dates.  
      • <b>@DateFormat</b> — this annotation takes a single argument.  It is used to change the default date formatting to that specified in the argument.  Like the ToDate() method, above, the specification uses the syntax of the MomentJs library.  Note that @DateFormat can be explicitly overridden by the use of the ToDate method
      • <b>@EncodeDataFor</b> — this annotation, which takes a single argument that must be 'html', 'xml' or 'uri', is used to automatically encode any data values encountered during the processing of a template.  Since templates consist of literal strings that can be encoded when they are specified, this annotation insures that data values are similarly encoded.  Note that the EncodeFor method does not override the effects of this annotation; the two are intended to be used together
      • <b>@DefaultIndent</b> — this annotation takes a single numerical argument that specifies the number of spaces, from 0 to 25, that will be used whenever implicit indenting occurs as the result of interpolating a multi-valued attribute.  By default, TextTemplate indents 3 spaces, and this annotation can modify that behavior.  Note that this annotation only affects implicit indenting and does not affect indents that are explicitly specified in templates
      • <b>@BulletStyle</b> — this annotation takes a variable number of arguments.  By default and when @BulletStyle is specified with no argument, bullets are displayed as with a level and index of the bullet in parenthesis, as in "(3.2)" that can be used for debugging.  @BulletStyle provides a means of specifying how each level of the bulleting will be formatted, with a separate argument for each level.  The last argument is used whenever an outline contains more levels than the number of arguments.  Bullets can be symbols and punctuations plus numerical indicators that are formatted as alphabetical, numerical or roman numeral sequences.  Five characters are used to specify numerical sequences: a, which stands for lower case alphabetic, A, upper case alphabetic, I, upper case Roman numerals, i, lower case roman numerals.  A bullet specification can indicate a capital letter surrounded by parenthesis, like "(A)", a number followed by a period, like "1.", etc.  When the numerical sequence indicators are preceded by spaces, that indicates that the sequence should be right aligned to the width of the number and the spaces, as in " 1.".  Multiple numerical sequences to be used in a single specification to provide legal numbering, where a specification like "1.1.1(a)", could produce a bullet like "4.2.3(b)".  Multiple numerical sequences are computed from right, the inner-most level, to the left.  In this way, it is possible to use multiple numerical sequences that reflect the level and index of only the inner-most few bullets.  Bullet specifiers also support initial values for numerical sequences.  By following the numerical sequence with a colon and a an example of the numerical sequence, the specification indicates that the sequence should start with the value following the colon.  For example, the specification "I:IV" would indicate that the Roman numeral sequence should begin with "IV".  
      • <b>@BulletMode</b> — this annotation takes a single argument that can be either "implicit" or "explicit".  TextTemplate bulleting supports a mix of bulleted and non-bulleted lines that are intermixed.  When calculating bullet numbering, TextTemplate can take into account the fact that a non-bulleted text line is indented less than some of the bullets in an outline.  Under this circumstance, it will reset the index of all bullets that are further to the right of an indented line, only if the bullet mode is "implicit" (the default).  When the mode is "explicit", the indeces of bullets that might have been interrupted by the non-bulleted line continue to advance.
      • <b>@Falsy</b> — This annotation takes a single regular expression argument.  The annotation is used to indicate that certain values can be interpreted as false.  Many databases represent true with "1" and false with "0".  The @Falsy specification provides a means by which TextTemplate can evaluate a value used in a predicate.  By default, all values that are missing, null or an empty string are considered false, while all other values are evaluated as true.  the @Falsy specification of /^0$/ indicates that "0" is also to be evaluated as false.
      • <b>@Include</b> — This annotation is used to invoke shared annotations and subtemplates that might be used by several templates.  Since normally the scope of annotations and subtemplates is limited to the template that is being annotated and any subtemplates invoked within it, the effect of invoking a shared subtemplate with annotations and subtemplates would not persist beyond that invocation.  @Include is a mechanism for calling a shared subtemplate, specified by name as the first argument.  Upon completion of the subtemplate invoked by @Include, any annotations on that subtemplate as well as any subtemplates loaded by the subtemplate are retained on the template or subtemplate that invoked the @Include.
   (f) <b>Debugging methods</b> — TextTemplate provides a number of mechanisms to help the template writer correct errors in the template.
      • <b>ToJson</b> — The method, which takes no arguments, can be invoked on any specification in a template.  In this way, the contents of variables, context variables, and even templates can be emited within the output of a template.  
      • <b>Assert</b> — This method is designed to confirm that the output of a template has remained a predicted value.  The method takes between one and three arguments.  With one argument, the method is essentially the same as the Match method with a single operator, comparing the argument.  If the value matches the argument, the value remains the same.  If it does not match, the method emits an "ASSERT FAILURE" message followed by an indication of the mismatch.  An optional second argument can be specified as a substitute value for a true comparison and an optional thir argument can be provided to specify a replacement for the "ASSERT FAILURE" sequence.  
      • <b>Debugging Notations</b> — In addition to the above, TextTemplate exposes the current annotations as the "@" variable and provides two special attributes, @.Tokens and @.Tree.  @Tokens displays the current lexical tokens used in parsing a template, and @.Tree emits a representation of the parse tree
   (g) <b>Subtemplates as Methods</b> — Subtemplates can be invoked as methods on any TextTemplate variable or computed value by preceding the name with a dot and following the name with parenthesis, with our without arguments.  A subtemplate invoked as a method runs in a context that has special "$" variables.  $0 represents the value upon which the method has been invoked.  $1, $2, $3, etc. are used to represent any arguments passed to the subtemplate method.

X. <b>Data navigation</b> — The TextTemplate language is designed to process hierarchical data without limit.  Context tokens are used to descend in the hierarchy so that all identifiers in the context token's subtemplate reference attributes within that context.  In this way, most interpolation is likely to occur at a specific level, but occasionally a template will need to examine or emit a value from a higher level in the hierarchy.  The TextTemplate language provides the carat symbol, "^", to allow a template to access the parent of the current context.  A succession of carat symbols, as in "^.^.^.attribute" can be used to navigate to the top and, since the topmost caret points to itself, there is not concern about navigating above the top.

XI. <b>Null evaluation</b> — By default, will eliminate text lines that have a missing or null value anywhere in the line.  This is specifically designed to eliminate the necessity to test for the presence of all values necessary to fully interpolate a template and is similar to the way that databases typically deal with null results.  This behavior can cause confusion when text disappears possibly due to a mistaken variable referenc, but the behavior can be globally modified by temporarily or permanently applying a @MissingValue annotation.

XII. <b>Comments</b> — The TextTemplate language supports two kinds of comments taken from Java/C/C++/C#. All contents between (and including) a slash star/star slash pair is ignored.  All contents following (and including) double slashes, including any white space prior to the double slashes up to but not including a new line is ignored.

XIII. <b>White space</b> — the TextTemplate language generally permits white space freely within tokens and parenthetical expressions without affecting interpolation.  On the other hand, white space within literals is taken literally and since templates and subtemplates are composed of literal strings, white space and new lines within templates will be taken literally with some notable exceptions.  If the bracket that begins a subtemplate is followed by white space up to a new line, all of that white space including the new line and any following white space will be ignored.  Likewise, if the right bracket ending a template is preceded by only white space and a carriage return, all contents starting from the white space (if any) at the end of the previous line up to the right bracket will be ignored.  This behavior is provided to allow structured syntax that makes conditional execution more apparent.  For example, the following specification for a template that produces two sentences depending on some condition can be optimally structured as:
      
          [the output of the test {condition='yes' =&gt;
               [
                  requires this true text
               ],[
                  needs this false text
               ]
         } to demonstrate whitespace.]
            
   This behavior can be defeated by placing a "//" comment on the line with the bracket.  The comment, which ignores leaves the new line intact, takes precedence over the bracket whitespace detection.

XIV. <b>Continuation</b> — Very long text lines in templates can be broken into parts by using a tick mark ("`") at the end of a line.  When that mark is detected, all white space prior to the tick plus the new line and additional white space after the tick is replaced by a single space providing there are other.</pre></div>