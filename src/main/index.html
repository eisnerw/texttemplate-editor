<!DOCTYPE html>
<html>
<head>
	<title>TextTemplate Editor</title>
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
	<link rel="stylesheet" href="css/style.css">
	<style>
	pre {
		overflow-x: auto;
		white-space: pre-wrap;
		white-space: -moz-pre-wrap;
		white-space: -pre-wrap;
		white-space: -o-pre-wrap;
		word-wrap: break-word;
	}
	.button {
		background-color: #ddd;
		border: none;
		color: black;
		padding: 10px 20px;
		text-align: center;
		text-decoration: none;
		display: inline-block;
		margin: 4px 2px;
		cursor: pointer;
		border-radius: 16px;
	}
	.button:hover {
		background-color: #D7D3D2;
	}
	</style>
</head>
<body>

<div style='margin-block-end: 0.83em;'>
	<span style='font-size: 1.5em;font-weight: bold;'>TextTemplate Editor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
	<input type="checkbox" checked=true id="autorun"><label for="vehicle1">Run automatically when editor content changes:</label>
	<span style='font-size: 1.5em;font-weight: bold;'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
	<button id='run' class='button' onclick='return window.editorChanged("button");'>Run</button>
</div>
<div id="container" style="width:800px;height:600px;border:1px solid grey; float:left"></div>
<div><pre id="interpolated"></pre></div>
<script src="node_modules/monaco-editor/min/vs/loader.js"></script>
<script src="js/main.js"></script>

<script>
	require.config({ paths: { 'vs': 'node_modules/monaco-editor/min/vs' }});

	require(['vs/editor/editor.main'], function() {
		monaco.languages.register({ id: 'texttemplate' });

		let parserFacade;

		monaco.languages.setTokensProvider('texttemplate', new TextTemplateTokensProvider.TextTemplateTokensProvider());
		let config = {
			"surroundingPairs": [
				{ "open": "{", "close": "}" }
				,{ "open": "[", "close": "]" }
				,{ "open": '(', "close": ')' }
			], 
			"autoClosingPairs": [
				{ "open": "{", "close": "}" }
				,{ "open": "[", "close": "]" }
				,{ "open": '(', "close": ')' }
			], 
			"brackets": [
				["{", "}"]
				,["[", "]"]
				,["(", ")"]
			]
		};
		monaco.languages.setLanguageConfiguration("texttemplate", config);
		monaco.languages.registerFoldingRangeProvider("texttemplate", {
			provideFoldingRanges: function(model, context, token) {
				return parserFacade.provideFoldingRanges(model, context, token);
			}
		});
		let commentFg= '008000'; //  green
		let textFg = 'A9A9A9'; // greyish
		let symbolsFg = '0000ff'; // blue
		let methodFg = 'ff0000'; // red
		let errorFg = 'ff0000'; // red
		let quoteFg = '32cd32'; // lime green
		let subtemplateFg = 'E6B794'; // pinkish
		let literalFg = '070D0D'; // almost black
		let bracketsFg = '000000'; // black
		let subtemplatesFg = '800080'; // purple
		let regexFg = 'FF8C00'; // dark orange
		//green = #008000
		//purple = #800080

		monaco.editor.defineTheme('myCoolTheme', {
			base: 'vs',
			inherit: false,
			rules: [
				{ token: 'text.texttemplate', foreground: literalFg},
				{ token: 'rp.texttemplate', foreground: methodFg},
				{ token: 'bullet.texttemplate', foreground: bracketsFg, fontStyle: 'bold'},
				{ token: 'rbrace.texttemplate', foreground: bracketsFg, fontStyle: 'bold'},
				{ token: 'thinarrow.texttemplate', foreground: bracketsFg, fontStyle: 'bold'},
				{ token: 'rbracket.texttemplate', foreground: bracketsFg , fontStyle: 'bold'},
				{ token: 'lp.texttemplate', foreground: methodFg },
				{ token: 'lbrace.texttemplate', foreground: bracketsFg , fontStyle: 'bold'},
				{ token: 'lbracket.texttemplate', foreground: bracketsFg, fontStyle: 'bold'},
				{ token: 'arrow.texttemplate', foreground: bracketsFg, fontStyle: 'bold'},
				{ token: 'colon.texttemplate', foreground: bracketsFg , fontStyle: 'bold'},
				{ token: 'comma.texttemplate', foreground: bracketsFg, fontStyle: 'bold' },
				{ token: 'methodname.texttemplate', foreground: methodFg },
				{ token: 'keyword.texttemplate', foreground: methodFg },
				{ token: 'pound.texttemplate', foreground: subtemplateFg},
				{ token: 'identifier.texttemplate', foreground: symbolsFg, fontStyle: 'italic'},
				{ token: 'comment.texttemplate', foreground: commentFg},
				{ token: 'quoted.texttemplate', foreground: literalFg},
				{ token: 'subtemplates.texttemplate', foreground: subtemplatesFg, fontStyle: 'bold' },
				{ token: 'error.texttemplate', foreground: errorFg, fontStyle: 'bold' },
				{ token: 'dot.texttemplate', foreground: methodFg },
				{ token: 'and.texttemplate', foreground: methodFg },
				{ token: 'or.texttemplate', foreground: methodFg},
				{ token: 'not.texttemplate', foreground: methodFg},
				{ token: 'tick.texttemplate', foreground: commentFg },
				{ token: 'lquote.texttemplate', foreground: quoteFg, fontStyle: 'bold' },
				{ token: 'rquote.texttemplate', foreground: quoteFg , fontStyle: 'bold' },
				{ token: 'lapostrophe.texttemplate', foreground: quoteFg , fontStyle: 'bold' },
				{ token: 'rapostrophe.texttemplate', foreground: quoteFg , fontStyle: 'bold' },
				{ token: 'poundidentifier.texttemplate', foreground: subtemplatesFg },
				{ token: 'regex.texttemplate', foreground: regexFg},
				{ token: 'unrecognized.texttemplate', foreground: errorFg }
			]
		});
		let createEditor = function(input){
			let editor = monaco.editor.create(document.getElementById('container'), {
				value: input,
				language: 'texttemplate',
				theme: 'myCoolTheme',
				scrollbar: {
					// Subtle shadows to the left & top. Defaults to true.
					useShadows: false,

					// Render vertical arrows. Defaults to false.
					verticalHasArrows: true,
					// Render horizontal arrows. Defaults to false.
					horizontalHasArrows: true,

					// Render vertical scrollbar.
					// Accepted values: 'auto', 'visible', 'hidden'.
					// Defaults to 'auto'
					vertical: 'visible',
					// Render horizontal scrollbar.
					// Accepted values: 'auto', 'visible', 'hidden'.
					// Defaults to 'auto'
					horizontal: 'visible',

					verticalScrollbarSize: 17,
					horizontalScrollbarSize: 17,
					arrowSize: 30
				}			
			});
			editorChanged = function (e) {
				let bButtonPressed = typeof e == 'string' && e == 'button';
				let bAutoRun = document.getElementById('autorun').checked;
				let mode = bAutoRun ? 1  : bButtonPressed ? 0 : 2;  // mode 0 = button; 1 = autorun; 2 = skip
				let code = bButtonPressed || bAutoRun ? editor.getValue() : ''; 
				let model = monaco.editor.getModels()[0];
				if (!ParserFacade && !parserFacade){
					return; // protect against an unknown error that can occur during editing if keystrokes are frequent
				} else {
					if (ParserFacade && !parserFacade){
						parserFacade = ParserFacade;
					}
				}
				setTimeout(function(){
					parserFacade.inputChanged(code, mode);
				},0);
			}
			editor.onDidChangeModelContent(editorChanged);
			monaco.languages.registerDefinitionProvider('texttemplate', {
				provideDefinition: function(model,position, token){
					console.log("got here");
				}
			});
			setTimeout(function(){
				editorChanged();
			},100);
		}
		let urlSplit = window.location.href.split('#');
		if (urlSplit.length != 2){
			createEditor([
					'// data context:',
					'{\'{"firstName": "John", "lastName": "Smith", "pets":[',
					'{"type":"dog", "name": "Toto"}',
					',{"type":"cat", "name": "Dolly"}',
					',{"type":"zebra", "name": "Stripes"}',
					']}\':',
					'// Template:',
					'[{"Hello"} {lastName}, {firstName} with {pets.Exists()=>',
					'   [{pets:#formatPet.Anded()}]',
					'   ,[no pets]',
					'}!!]}',
					'',
					' // external json data and an external subtemplate',
					'// {\'https://api.github.com/users/eisnerw/repos\': #formatGitRepos}', 
					'',
					'Subtemplates:',
					'',
					'{#formatPet:[a {type} named {name}]}',
					'{#formatPets:[{pets:[a big {type} named {name}].Anded()}]}',
					''
				].join('\n'));
		} else {
			$.ajax({
				url: '/template/' + urlSplit[1],
				success: function (data) {
					if (typeof data == 'string'){
						createEditor(data.replace(/\\\\n/g,"\0x01").replace(/\\n/g,"\n").replace(/\0x01/g,"\\n"));
					} else {
						createEditor(typeof data == 'object' && !!data.error ? data.error : 'ERROR calling ' + urlSplit[1]);
					}
				}
			});
		}
	});
</script>
<!--jQuery-->
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
</body>
</html>